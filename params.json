{"name":"Mailman","tagline":"Mailman provides a clean way of defining mailers in your Elixir applications","body":"## Mailman\r\n\r\nMailman provides a clean way of defining mailers in your Elixir apps. It allows you to send multi-part email messages containing text and html parts. It encodes messages with a proper quoted-printable encoding. It also allows you to send attachments.\r\n\r\nTo be able to send emails, you only need to provide the SMTP config (like an external SMTP server along with credentials etc.). You also need to define your emails along with text and/or html templates. Mailman uses Eex as a templating language but will likely be extended to provide other choices as well in the future.\r\n\r\n### A quick example\r\n\r\n```elixir\r\n  defmodule MyApp.Mailer do\r\n    def deliver(email) do\r\n      Mailman.deliver(email, config)\r\n    end\r\n\r\n    def config do\r\n      %Mailman.Context{\r\n          config:   %Mailman.LocalSmtpConfig{ port: 1234 },\r\n          composer: %Mailman.EexComposeConfig{}\r\n        }\r\n    end\r\n  end\r\n  \r\n  # somewhere where you start other services in your app:\r\n  Mailman.LocalServer.start 1234 # just pass the port number you want\r\n\r\n  # somewhere else:\r\n  def testing_email do\r\n    %Mailman.Email{\r\n      subject: \"Hello Mailman!\",\r\n      from: \"mailman@elixir.com\",\r\n      to: [ \"testy@tester123456.com\" ],\r\n      cc: [ \"testy2#tester1234.com\", \"abcd@defd.com\" ],\r\n      bcc: [ \"1234@wsd.com\" ],\r\n      data: [\r\n        name: \"Yo\"\r\n        ],\r\n      text: \"Hello! <%= name %> These are Unicode: qżźół\",\r\n      html: \"\"\"\r\n<html>\r\n<body>\r\n <b>Hello! <%= name %></b> These are Unicode: qżźół\r\n</body>\r\n</html>\r\n      \"\"\"\r\n      }\r\n  end\r\n```\r\n\r\nAnd then to actually send an email:\r\n```elixir\r\n  # Note that for now deliver/1 is blocking. In the future it will return a Task\r\n  MyApp.Mailer.deliver testing_email\r\n```\r\n\r\n### Configuring the mailing context\r\n\r\nThere are two parts in the configuration data for how Mailman works:\r\n\r\n* Composer config\r\n* Adapter config\r\n\r\nThe first one specifies how emails will be rendered. The second one, how\r\nwill they be delivered. \r\n\r\nFor now, only the `%Mailman.EexComposeConfig{}` is available for configuring the composer. The library is ready to support any other composer you might want to implement.\r\n\r\nThere are three adapter configs at the moment: external smtp, local smtp and the testing one. The latter will soon support handling the queue of emails to ease testing of the email sending part of your apps. \r\n\r\nYou don't access those adapters directly. Instead, you specify a config of your choice and the library does all the rest for you. The three config options corresponding with adapters are: `%Mailman.LocalSmtpConfig{}`, `%Mailman.SmtpConfig{}` and `%Mailman.TestConfig{}`.\r\n\r\n```elixir\r\n%Mailman.Context{\r\n    config:   %Mailman.LocalSmtpConfig{ port: 1234 },\r\n    composer: %Mailman.EexComposeConfig{}\r\n  }\r\n```\r\n\r\nNote that to be able to use the local and the test configs, you'll need to start either local SMTP server or the testing service:\r\n\r\n```elixir\r\n  Mailman.LocalServer.start(1234)\r\n  # or:\r\n  Mailman.TestServer.start\r\n```\r\n\r\nIn this example we're setting up the library to use the local SMTP server created along with the app. In order for this to work you still have to create this process:\r\n\r\n```elixir\r\npid = Mailman.LocalServer.start(1234)\r\n```\r\n\r\n### Defining emails\r\n\r\nThe email struct is defined as:\r\n\r\n```elixir\r\ndefstruct subject: \"\", \r\n  from: \"\", \r\n  to: [], \r\n  cc: [], \r\n  bcc: [], \r\n  attachments: [], # This has to be %Mailman.Attachment{}. More about attachments below\r\n  data: %{}, # This is the context for EEx. You put here data for your <%= %> placeholders\r\n  html: \"\", # Actual html template\r\n  text: \"\", # Actual plain template\r\n  delivery: nil # If the message was created through parsing of the delivered email - this holds the 'Date' header\r\n```\r\n\r\n### Attaching files\r\n\r\nA dedicated struct has been created for describing attachments. In this version, there's a function that takes a binary representing a path to a file that's constructing this struct for you. So you can add attachments to your email definitions like this:\r\n\r\n```elixir\r\nattachments: [\r\n  Mailman.Attachment.inline!(\"test/data/blank.png\")\r\n  ],\r\n```\r\n\r\nThis reads the file from disk, encodes it with base64 and discovers the proper mime-type. Attachments are also properly decoded from existing emails (more on that below).\r\n\r\n### Parsing delivered emails\r\n\r\nIf you have the source of rendered email as a binary, you can use the `Mailman.Email.parse!/1` function to turn it into`%Mailman.Email{}`.\r\n\r\nHere's an example from the test suite:\r\n\r\n```elixir\r\n{:ok, message} = Task.await MyApp.Mailer.deliver(email_with_attachments)\r\nemail = Mailman.Email.parse! message\r\n```\r\n\r\nAt this point, if the source contains the 'Date' header (meaning that it was put through a mailing system) — it will have the 'delivery' field non-empty.\r\n\r\n### Inspecting deliveries when testing\r\n\r\nWhen you use the TestServer you can take a look at the deliveries whith:\r\n\r\n```elixir\r\n  Mailman.TestServer.deliveries\r\n```\r\n\r\nAlso, if you want to clear this list:\r\n\r\n```elixir\r\n  Mailman.TestServer.clear_deliveries\r\n```\r\n\r\n## TODOs\r\n\r\n- [x] A SMTP config that would use internal server/process coming with :gen_smtp\r\n- [x] A testing config that stores deliveries\r\n- [x] Ability to send attachments\r\n- [x] Ability to provide CC and BCC\r\n- [ ] Unit testing (somewhat in progress)\r\n\r\n## Contributors\r\n\r\n* Josh Adams ([https://github.com/knewter]())\r\n* Dan McClain ([https://github.com/danmcclain]())\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}